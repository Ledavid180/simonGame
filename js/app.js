//create an array to keep track of the original sequence of tile clicks and a second array for the human sequence
let sequence = [];
let humanSequence = [];
let level = 0;

//select start button and create a new startGame() function that will be executed when this button is clicked
const startBtn = document.querySelector('.js-start');
const info = document.querySelector('.js-start');
const heading = document.querySelector('.js-heading');
const tileContainer = document.querySelector('.js-container');

//we need to compare the order in which the player taps the buttons to the order of the sequence generated by the game. If the order does not match, the game resests and a message is shown alerting the player to failure. 
function resetGame(text) {
    alert(text);
    sequence = [];
    humanSequence = [];
    level = 0;
    startBtn.classList.remove('hidden');
    heading.textContent = 'Simon Game';
    info.classList.add('hidden');
    tileContainer.classList.add('unclickable');
}
function humanTurn(level){
    //first step is to remove the unclickable class from the tile container. This class prevents the buttons from being pressed when the game has not started and when the AI is not finished with the sequence of presses. 
    tileContainer.classList.remove('unclickable');
    //the contents of the info element are changed to indicate that the player can begin to repeat the sequence. It also shows how many taps needs to be entered.
    info.textContent = `Your turn: ${level} Tap${level > 1 ? 's' : ''}`;
}
//activateTile() uses the value of color to select the appropriate tile and audio elements. In the HTML file, notice how the data-sound attribute on the audio elements corresponds to the button colors.
function activateTile(color){
    const tile = document.querySelector(`[data-tile='${color}']`);
    const sound = document.querySelector(`[data-sound='${color}']`);

    //the activated class is added to the selected tile 
    tile.classList.add('activated');
    //& the play() method is triggered on the selected audio element causing the linked mp3 file in the src attribute to be played. After 300 milliseconds, the activated class is removed again. The effect is that each tile is activated for 300ms, and there are 300ms between tile activations in the sequence.
    sound.play();

    setTimeout(() => {
        tile.classList.remove('activated');
    }, 300);
}

//playRound() takes a sequence array and iterates over it. Then uses setTimeout() to call the activateTile() at 600 millisecond intervals for each value in the sequence. The reason setTimeout() is used here is to add an artificial delay between each button press. Without it, the tiles in the sequence will be activated all at once.
function playRound(nextSequence) {
    nextSequence.forEach((color, index) => {
        setTimeout(() => {
            activateTile(color);
        }, (index + 1) * 600);
    })
}

function nextStep(){
    const tiles = ['red', 'green', 'blue', 'yellow'];
    const random = tiles[Math.floor(Math.random() * tiles.length)];

    return random;
}
//nextRound() increments the level each time it is called and also prepares the next sequence. each new round builds upon the previous one so what we need to do is copy the existing order of button presses and add a new random one to it. 
function nextRound(){
    level += 1;
    //the unclickable class is added to the tile container when the round starts, and the contents of the info and heading elements are updated.
    tileContainer.classList.add('unclickable');
    info.textContent = 'Wait for the computer';
    heading.textContent = `Level ${level} of 20`;

    //line below copies all of the elements in the 'sequence' array to the 'nextSequence' varaible
    const nextSequence = [...sequence];
    nextSequence.push(nextStep());
    playRound(nextSequence);

    //humanTurn needs to be exectued after the computer's sequence is over so we cannot call it immediately. We need to add an artificial delay and calculate when the computer will be done with the sequence of button taps.
    //this setTimeout function executes humanTurn() one second after the last button in the sequence is activated. The total furation of the sequence corresponds to the current level multiplied by 600ms which is the duration for each tile in the sequence. The sequence variable is also assigned to the updated sequence.
    sequence = [...nextSequence];
    setTimeout(() => {
        humanTurn(level);
    }, level * 600 + 1000);
}

//this function below pushes the tile value to the humanSequence array and stores its index in the index varaible. The corresponding sound for the button is played and the remaining steps in the sequence is calculated and updated on the screen.
function handleClick(tile){
    const index = humanSequence.push(tile) - 1;
    const sound = document.querySelector(`[data-sound='${tile}']`);
    sound.play();

    const remainingTaps = sequence.length - humanSequence.length;


    //if the value of the element retrieved by the index in both the sequence and humanSequence arrays do not match, it means the player made a wrong turn. At that point, an alert is displayed and the game resets.
    if(humanSequence[index] !== sequence[index]) {
        resetGame('Oops! Game over, you pressed the wrong tile!');
        return;
    }
    //code below compares the length of the humanSequence array to sequence array. If they're equal, it means that the round is over and the next round can begin. At that point, the humanSeqeunce array is reset and the nextRound() function is called after one second. The delay is to allow the user to see the success message, otherwise, it will not appear at all because it will get overwritten immediately.
    if(humanSequence.length === sequence.length) {
        humanSequence = [];
        info.textContent = 'Success! Keep Going!';
        setTimeout(() => {
            nextRound();
        }, 1000);
        return;
    }

    info.textContent = `Your turn: ${remainingTaps} Tap${
        remainingTaps > 1 ? 's' : ''
    }`;
}

function startGame(){
    startBtn.classList.add('hidden');
    info.classList.remove('hidden');
    info.textContent = 'It is the computer\'s turn.';
    nextRound();
}

startBtn.addEventListener('click', startGame);
//to detect the player's button taps and decide whether to move to the next round or end the game.
tileContainer.addEventListener('click', event => {
    const { tile } = event.target.dataset;
    if (tile) hadleClick(tile);
    //the value of data-tile on the element that was clicked is accessed and stored in the tile varaible. If the value is not an empty string(for elements without the data-tile attribute), the handleClick() function is executed with the tile value as its only argument.
})